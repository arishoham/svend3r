{
  "slug": "chord",
  "title": "Chord Diagram",
  "code": "`<script>\n  import * as d3 from 'd3';\n  import { sampleData } from './sampleData.js'\n  const data = sampleData;\n  const marginOffset = ${$ChordChartDocs[1].value} //the margin top, bottom, left, right margin offset relative to the radius\n  const width = ${$ChordChartDocs[2].value}; // the outer width of the chart, in pixels\n  const height = width; // the outer height of the chart, in pixels\n  const bandThickness = ${$ChordChartDocs[3].value}; // the thickness of the color band representing each dataset\n  const fontSize = ${$ChordChartDocs[4].value} //the label font size relative to 1% of the width of the viewport\n  const tickStep = ${$ChordChartDocs[5].value}; //the chart label tick spread factor\n  const scaleFormat = '${$ChordChartDocs[6].value}'; // a format specifier string for the scale ticks\n  const names = [${\"'\" + $ChordChartDocs[7].value.join(\"','\") + \"'\"}]; // section names\n  const colors = [${\"'\" + $ChordChartDocs[8].value.join(\"','\") + \"'\"}]; // section fill colors && number of colors in fill array MUST match number of subsets in data\n  const chordOpacity = ${$ChordChartDocs[9].value}; //the opacity for the charts overall chords\n  const unselectOpacity = ${$ChordChartDocs[10].value}; //the opacity of non-select chart elements\n  const selectOpacity = ${$ChordChartDocs[11].value}; //the opacity of select chart elements\n  const tooltipBackground = '${$ChordChartDocs[12].value}'; // background color of tooltip\n  const tooltipTextColor = '${$ChordChartDocs[13].value}'; // text color of tooltip\n  const outerRadius = Math.min(width, height) * 0.5 - marginOffset; // should connect to margin\n  const innerRadius = outerRadius - bandThickness; // should make adjustable\n  \n  let groupInfo, ribbonInfo;\n  $: selectedChord = null;\n  const chord = d3.chord()\n    .padAngle(10 / innerRadius)\n    .sortSubgroups(d3.descending)\n    .sortChords(d3.descending);\n  const chords = chord(data);\n  const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius);\n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(1 / innerRadius);\n  function ticks({startAngle, endAngle, value}) {\n    const k = (endAngle - startAngle) / value;\n    return d3.range(0, value, (tickStep/100)).map(value => {\n      return {value, angle: value * k + startAngle};\n    });\n  }\n  function formatValue(val) {\n    return (val * 100).toFixed(2) + scaleFormat;\n  }\n<\\/script>\n<svg {width} {height} viewBox=\"{-width / 2} {-height / 2} {width} {height}\">\n  {#each chords.groups as group, i}\n    <path fill={colors[i]} d={arc(group)}\n      on:mouseover=\"{(e) => groupInfo = [i, e, group.value]}\"\n      on:focus=\"{(e) => groupInfo = [i, e]}\"\n      on:mouseout=\"{() => groupInfo = null}\"\n      on:blur=\"{() => groupInfo = null}\" />\n    {#each ticks(group) as groupTick}\n      <g transform=\"rotate({groupTick.angle * 180 / Math.PI - 90}) translate({outerRadius}, 0)\">\n        <line stroke='black' x2='6'/>\n        <text x='8' dy='0.35em' font-size=\"{fontSize}vw\"\n          transform=\"{groupTick.angle > Math.PI ? \"rotate(180) translate(-16)\" : null}\"\n          text-anchor=\"{groupTick.angle > Math.PI ? \"end\" : null}\"\n          font-weight=\"{groupTick.value !== 0 ? \"normal\" : \"bold\"}\">\n          {groupTick.value !== 0 ? Math.round(groupTick.value * 100) + scaleFormat : names[i]}\n        </text>\n      </g>\n    {/each}\n  {/each}\n  \n  {#each chords as chord}\n    {#if selectedChord}\n      <path fill-opacity={selectedChord === chord ? selectOpacity : unselectOpacity} fill={colors[chord.source.index]} d={ribbon(chord)} \n        on:mouseover=\"{(e) => {ribbonInfo = [e, chord]; selectedChord = chord; }}\"\n        on:focus=\"{(e) => {ribbonInfo = [e, chord]; selectedChord = chord; }}\"\n        on:mouseout=\"{() => { ribbonInfo = null; selectedChord = null; }}\"\n        on:blur=\"{() => { ribbonInfo = null; selectedChord = null; }}\"\n      />\n    {:else}\n    <path fill-opacity={chordOpacity} fill={colors[chord.source.index]} d={ribbon(chord)} \n      on:mouseover=\"{(e) => {ribbonInfo = [e, chord]; selectedChord = chord; }}\"\n      on:focus=\"{(e) => {ribbonInfo = [e, chord]; selectedChord = chord; }}\"\n      on:mouseout=\"{() => { ribbonInfo = null; selectedChord = null; }}\"\n      on:blur=\"{() => { ribbonInfo = null; selectedChord = null; }}\"\n    />\n    {/if}\n  {/each}\n</svg>\n<!-- Group Tooltip -->\n{#if groupInfo}  \n  <div style=\"position:absolute; left:{groupInfo[1].clientX + 12}px; top:{groupInfo[1].clientY + 12}px; background-color:{tooltipBackground}; color:{tooltipTextColor}\">\n    {names[groupInfo[0]]}: {(groupInfo[2] * 100).toFixed(2)}{scaleFormat}\n  </div>\n{/if}\n<!-- Ribbon Tooltip -->\n{#if ribbonInfo}  \n  <div style=\"position:absolute; left:{ribbonInfo[0].clientX + 12}px; top:{ribbonInfo[0].clientY + 12}px; background-color:{tooltipBackground}; color:{tooltipTextColor}\">\n    {formatValue(ribbonInfo[1].source.value)} {names[ribbonInfo[1].target.index]} → {names[ribbonInfo[1].source.index]}\n    {ribbonInfo[1].source.index === ribbonInfo[1].target.index \n    ? '' \n    // eslint-disable-next-line max-len\n    : \\`\\\\n\\${formatValue(ribbonInfo[1].target.value)} \\${names[ribbonInfo[1].source.index]} → \\${names[ribbonInfo[1].target.index]}\\`}\n  </div>\n{/if}\n  \n<style>\n  div {\n    white-space: pre;\n  }\n</style>\n`",
  "chartData": "const sampleData = [\n  [0.096899, 0.008859, 0.000554, 0.00443, 0.025471, 0.024363, 0.005537, 0.025471],\n  [0.001107, 0.018272, 0, 0.004983, 0.011074, 0.01052, 0.002215, 0.004983],\n  [0.000554, 0.002769, 0.002215, 0.002215, 0.003876, 0.008306, 0.000554, 0.003322],\n  [0.000554, 0.001107, 0.000554, 0.012182, 0.011628, 0.006645, 0.004983, 0.01052],\n  [0.002215, 0.00443, 0, 0.002769, 0.104097, 0.012182, 0.004983, 0.028239],\n  [0.011628, 0.026024, 0, 0.013843, 0.087486, 0.168328, 0.017165, 0.055925],\n  [0.000554, 0.004983, 0, 0.003322, 0.00443, 0.008859, 0.017719, 0.00443],\n  [0.002215, 0.007198, 0, 0.003322, 0.016611, 0.01495, 0.001107, 0.054264]\n];\nexport { sampleData };",
  "schema": "\n    const relationalData = [\n        [A_A, A_B, A_C, A_D, A_E, A_F, A_G, A_H], \n        [B_A, B_B, B_C, B_D, B_E, B_F, B_G, B_H],\n        [C_A, C_B, C_C, C_D, C_E, C_F, C_G, C_H],\n        [D_A, D_B, D_C, D_D, D_E, D_F, D_G, D_H],\n        [E_A, E_B, E_C, E_D, E_E, E_F, E_G, E_H],\n        [F_A, F_B, F_C, F_D, F_E, F_F, F_G, F_H],\n        [G_A, G_B, G_C, G_D, G_E, G_F, G_G, G_H],\n        [H_A, H_B, H_C, H_D, H_E, H_F, H_G, H_H],\n        //insert additional inter-relational matrixed data...\"\n    ];\n    //Note array length and element length must be equal for a relational dataset\n    export { sampleData };\n    ",
  "properties": [{"variable":"data","value":"sampleData","dataType":"Array","description":"An array of objects with x-axis and y-axis key value pairs.","defaultValue":"sampleData"},{"variable":"marginOffset","value":100,"dataType":"Number","description":"The margin top, bottom, left, right margin offset relative to the radius.","defaultValue":100,"min":0,"max":180},{"variable":"width","value":800,"dataType":"Number","description":"The outer width of the chart, in pixels.","defaultValue":800,"min":370,"max":700},{"variable":"bandThickness","value":10,"dataType":"Number","description":"The thickness of the color band representing each dataset.","defaultValue":10,"min":0,"max":100},{"variable":"fontSize","value":1,"dataType":"Number","description":"The label font size relative to 1% of the width of the viewport.","defaultValue":1,"min":0.1,"max":1},{"variable":"tickStep","value":1,"dataType":"Number","description":"The chart label tick spread factor.","defaultValue":1,"min":1,"max":5},{"variable":"scaleFormat","value":"%","dataType":"String","description":"The format specifier string for the scale ticks.","defaultValue":"%"},{"variable":"names","value":["Apple","HTC","Huawei","LG","Nokia","Samsung","Sony","Other"],"dataType":"Array","description":"The section labels for each dataset.","defaultValue":["Apple","HTC","Huawei","LG","Nokia","Samsung","Sony","Other"]},{"variable":"colors","value":["#c4c4c4","#69b40f","#ec1d25","#c8125c","#008fc8","#10218b","#134b24","#737373"],"dataType":"Array","description":"The fill colors for each section.  The length of colors MUST match names variable array.","defaultValue":["#c4c4c4","#69b40f","#ec1d25","#c8125c","#008fc8","#10218b","#134b24","#737373"]},{"variable":"chordOpacity","value":0.7,"dataType":"Number","description":"The opacity for the charts overall chords.","defaultValue":0.7,"min":0.1,"max":1},{"variable":"unselectOpacity","value":0.1,"dataType":"Number","description":"The opacity of non-select chart elements.","defaultValue":0.1,"min":0.1,"max":1},{"variable":"selectOpacity","value":0.7,"dataType":"Number","description":"The opacity of select chart elements.","defaultValue":0.7,"min":0.1,"max":1},{"variable":"tooltipBackground","value":"lightgrey","dataType":"String | RGB | Hex","description":"The background color of the tooltip.","defaultValue":"lightgrey"},{"variable":"tooltipTextColor","value":"black","dataType":"String | RGB | Hex","description":"The text color of the tooltip.","defaultValue":"black"}]
}